<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Universal Gravitation with Phaser</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
  <style>
    body {
      margin: 0;
    }
    canvas {
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
  <script>
    const config = {
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { x: 0, y: 0 },
          debug: false
        }
      },
      type: Phaser.AUTO,
      width: 800,
      height: 600,
      backgroundColor: '#1e1e1e',
      scene: {
        preload,
        create,
        update
      }
    };

    const G = 3e-1;
    let sun, planet, spaceship;
    let solarSystems = [];
    let trail = [];
    let graphics;
    let sunLabel, planetLabel, spaceshipLabel;
    let cursors;

    const game = new Phaser.Game(config);

    function preload() {}

    function create() {
      this.minimap = this.cameras.add(600, 10, 150, 150).setZoom(0.05).setName('mini');
      this.minimap.setBackgroundColor(0x000000);
      this.minimap.setBounds(-1000, -1000, 3000, 3000);
      this.minimap.scrollX = -1000;
      this.minimap.scrollY = -1000;
      // Add quadrant objects and border visual
      const border = this.add.rectangle(500, 500, 3000, 3000).setStrokeStyle(4, 0xffffff, 0.5);
      border.setOrigin(0);
      border.setPosition(-1000, -1000);

      this.add.text(-900, -900, 'Top-Left', { font: '16px Arial', fill: '#aaa' });
      this.add.text(1800, -900, 'Top-Right', { font: '16px Arial', fill: '#aaa' });
      this.add.text(-900, 1800, 'Bottom-Left', { font: '16px Arial', fill: '#aaa' });
      this.add.text(1800, 1800, 'Bottom-Right', { font: '16px Arial', fill: '#aaa' });

      this.coordText = this.add.text(0, 0, '', { font: '14px Courier', fill: '#ffffff' }).setScrollFactor(0);

      const worldSize = 3000;
      const worldOrigin = -1000;
      this.cameras.main.setBounds(worldOrigin, worldOrigin, worldSize, worldSize);
      this.physics.world.setBounds(worldOrigin, worldOrigin, worldSize, worldSize);

      graphics = this.add.graphics();
      cursors = this.input.keyboard.createCursorKeys();

      const solarSystemData = [
        {
          x: 400, y: 300,
          planets: [
            { offsetX: 200, offsetY: 0, vx: 0, vy: -2.0, mass: 100, color: 0x00aaff },
            { offsetX: 0, offsetY: 250, vx: 1.5, vy: 0, mass: 100, color: 0x00ddaa }
          ]
        },
        {
          x: -600, y: -600,
          planets: [
            { offsetX: 200, offsetY: 0, vx: 0, vy: -2.0, mass: 100, color: 0x00aaff }
          ]
        },
        {
          x: 1600, y: -600,
          planets: [
            { offsetX: 200, offsetY: 0, vx: 0, vy: -2.0, mass: 100, color: 0x00aaff }
          ]
        },
        {
          x: -600, y: 1600,
          planets: [
            { offsetX: 200, offsetY: 0, vx: 0, vy: -2.0, mass: 100, color: 0x00aaff }
          ]
        },
        {
          x: 1600, y: 1600,
          planets: [
            { offsetX: 200, offsetY: 0, vx: 0, vy: -2.0, mass: 100, color: 0x00aaff }
          ]
        }
      ];

      for (const { x, y, planets: planetDefs } of solarSystemData) {
        let totalPx = 0, totalPy = 0, totalMass = 0;
        for (const pd of planetDefs) {
          totalPx += pd.vx * pd.mass;
          totalPy += pd.vy * pd.mass;
          totalMass += pd.mass;
        }
        const sunMass = 2000;
        const sunVx = -totalPx / sunMass;
        const sunVy = -totalPy / sunMass;

        const s = this.add.circle(x, y, 20, 0xffff00);
        s.vx = sunVx;
        s.vy = sunVy;
        this.physics.add.existing(s);
        s.body.setCollideWorldBounds(true);
        s.mass = sunMass;

        const sl = this.add.text(x, y - 30, 'Sun', {
          font: '16px Arial', fill: '#ffff00', align: 'center'
        }).setOrigin(0.5);

        const planets = [];
        for (const pd of planetDefs) {
          const px = x + pd.offsetX;
          const py = y + pd.offsetY;
          const p = this.add.circle(px, py, 16, pd.color);
          p.vx = pd.vx;
          p.vy = pd.vy;
          p.mass = pd.mass;
          const pl = this.add.text(px, py - 30, 'Planet', {
            font: '16px Arial', fill: Phaser.Display.Color.IntegerToColor(pd.color).rgba, align: 'center'
          }).setOrigin(0.5);
          planets.push({ body: p, label: pl });
        }

        solarSystems.push({ sun: s, planets: planets, sunLabel: sl });
      }
      }

      // Assign the central system to sun/planet for reference (e.g. trail)
      ({ sun, planet } = solarSystems[0]);

      spaceship = this.add.circle(300, 100, 10, 0xff00ff);
      spaceship.setInteractive();
      this.physics.add.existing(spaceship);
      spaceship.body.setCollideWorldBounds(true);
      spaceship.mass = 0.5;
      spaceship.vx = 1.2;
      spaceship.vy = 0.5;

      this.cameras.main.startFollow(spaceship, true, 0.1, 0.1);
      this.cameras.main.setZoom(1);

                  spaceshipLabel = this.add.text(spaceship.x, spaceship.y - 30, 'Spaceship', {
        font: '16px Arial',
        fill: '#ff00ff',
        align: 'center'
      }).setOrigin(0.5);

      this.minimap.ignore(this.coordText);
    }

    function update() {
      this.coordText.setText(`X: ${spaceship.x.toFixed(0)}, Y: ${spaceship.y.toFixed(0)}`);
      this.coordText.setPosition(10, 10);
      graphics.clear();
      drawGrid();
      for (const sys of solarSystems) {
        for (const p of sys.planets) {
          applyGravity(sys.sun, p.body);
          applyGravity(p.body, sys.sun);
          applyGravity(p.body, spaceship);
          applyGravity(sys.sun, spaceship);
        }
        
      }

      // Player controls for spaceship thrust
      const thrust = 0.05;
      let flame = false;
            if (cursors.left.isDown) { spaceship.vx -= thrust; flame = true; }
      if (cursors.right.isDown) { spaceship.vx += thrust; flame = true; }
      if (cursors.up.isDown) { spaceship.vy -= thrust; flame = true; }
      if (cursors.down.isDown) { spaceship.vy += thrust; flame = true; }

      for (const sys of solarSystems) {
        for (const p of sys.planets) {
          p.body.x += p.body.vx;
          p.body.y += p.body.vy;
          p.label.setPosition(p.body.x, p.body.y - 30);
        }
        sys.sun.x += sys.sun.vx;
        sys.sun.y += sys.sun.vy;
                sys.sunLabel.setPosition(sys.sun.x, sys.sun.y - 30);
      }

      spaceship.x += spaceship.vx;
      spaceship.y += spaceship.vy;

            spaceshipLabel.setPosition(spaceship.x, spaceship.y - 30);

      // Draw flame trail
      if (flame) {
        graphics.fillStyle(0xff6600, 1);
        graphics.beginPath();
        graphics.moveTo(spaceship.x, spaceship.y);
        graphics.lineTo(spaceship.x - spaceship.vx * 8 + 4, spaceship.y - spaceship.vy * 8 + 4);
        graphics.lineTo(spaceship.x - spaceship.vx * 8 - 4, spaceship.y - spaceship.vy * 8 - 4);
        graphics.closePath();
        graphics.fillPath();
      }

      trail.push({ x: planet.x, y: planet.y });
      if (trail.length > 500) trail.shift();

      drawTrail();
    }

    function applyGravity(bodyA, bodyB) {
      const dx = bodyA.x - bodyB.x;
      const dy = bodyA.y - bodyB.y;
      const distSq = dx * dx + dy * dy;
      const dist = Math.sqrt(distSq);
      if (dist < 1) return;
      const force = (G * bodyA.mass * bodyB.mass) / distSq;
      const ax = force * dx / dist / bodyB.mass;
      const ay = force * dy / dist / bodyB.mass;
      bodyB.vx += ax;
      bodyB.vy += ay;
    }

    function drawGrid() {
      const gridSize = 50;
      const cam = game.scene.scenes[0].cameras.main;
      const topLeftX = cam.scrollX;
      const topLeftY = cam.scrollY;
      const bottomRightX = cam.scrollX + cam.width / cam.zoom;
      const bottomRightY = cam.scrollY + cam.height / cam.zoom;

      graphics.lineStyle(1, 0x555555, 0.6);

      for (let x = Math.floor(topLeftX / gridSize) * gridSize; x < bottomRightX; x += gridSize) {
        graphics.beginPath();
        graphics.moveTo(x, topLeftY);
        graphics.lineTo(x, bottomRightY);
        graphics.strokePath();
      }

      for (let y = Math.floor(topLeftY / gridSize) * gridSize; y < bottomRightY; y += gridSize) {
        graphics.beginPath();
        graphics.moveTo(topLeftX, y);
        graphics.lineTo(bottomRightX, y);
        graphics.strokePath();
      }
    }
      

    function drawTrail() {
      graphics.lineStyle(1, 0x00ffff, 0.3);
      graphics.beginPath();
      for (let i = 0; i < trail.length; i++) {
        const p = trail[i];
        if (i === 0) graphics.moveTo(p.x, p.y);
        else graphics.lineTo(p.x, p.y);
      }
      graphics.strokePath();
    }
  </script>
</body>
</html>
